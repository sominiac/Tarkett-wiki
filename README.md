# Tarkett wiki

## Оглавление:

- [Общие сведения о проекте](#общие-сведения-о-проекте).

- [Удалённый репозиторий](#удалённый-репозиторий).

- [Интегрированная среда разработки](#интегрированная-среда-разработки).

- [Реализация](#реализация).

## Общие сведения о проекте:

    Кто будет осуществлять поддержку этой wiki? Конечно же - мастер проекта.

### Глоссарий: 

- **Диалоговое окно** - это всплывающее окно со всеми её составляющими характеристиками, а именно привлечение внимания пользователя, блокировка взаимодействий пользователя со всем контентом не относящимся к всплывающему окну и т.д. Единственным отличием от стандартной терминологии является то что на проекте, как и в библиотеке sapui5 под диалоговым окном подразумевается любое всплывающее окно, в том числе и модальное.

- **Поповер** - это одна из разновидностей всплывающих окон, основное отличие в том что *поповер* не блокирует возможность пользователя взаимодействовать с контентом не относящемуся к всплывающему окну.

- **Форк** - 

- **Основная ветка** - это определённые ветки напрямую работать в которых могут только основатели. Нужно это для того что бы изменения не попадали в `dev` без проверки и для дополнительного контроля над релизами.

- **Код ревью** - 

## Удалённый репозиторий:

Tarkett использует git в качестве системы контроля версии. Для управления репозиторием используется [GitLab](https://dev.pyrobyte.ru/git/tarkett-front). А в качестве модели ветвления git используется что-то среднее между [**Issue Branch Workflow** и **Feature Branch Workflow**](https://www.atlassian.com/ru/git/tutorials/comparing-workflows/feature-branch-workflow).

> Так как же всё-таки работать с этим *репозиторием*?

Работа с git репозиторием производится посредством веток, а именно:

1. `Master` - основная ветка, выступает в качестве релизной. Сюда необходимо сливать только релизнутые изменения и обновления из форкнутых репозиториев. *Необходимо для того что бы была возможность сделать `hotfix`*

2. `Dev` - основная ветка разработки. Все законченные и протестированные обновления должны находиться здесь.

3. `Business_processes` - основная ветка для задач направленных на бизнес процессы.

4. `Contacts` - основная ветка для задач направленных на контакты.

5. `Price_management` - основная ветка для задач направленных на раздел согласование цен.

6. `Signing_of_documents` - основная ветка для задач направленных на подписание документов IS УКЭП.

#### Порядок работы с git репозиторием:

1. Создаём ветку в зависимости от расположения задачи.
2. Выполнили задачу закомитили её и отправили на пр если нужно, пр отправляется в туже самую ветку от которой и откалывались.
3. После реализации задачи и сливании ветки в основную - необходимо удалить рабочую ветку, что бы не захламлять репозиторий.

>Так как мы используем модель ветвления *Issue Branch Workflow*, то на одного разработчика - одна ветка, не учитывая исключения в виде задач обязывающих разработчиков работать в одной ветке.

>При отправке на пр обязательно помечаем нужно ли удалять данную ветку после ревью или нет. А так же уже на странице с пр нужно добавлять в комментарии список задач, которые были выполнены в данном пр.
>>Так же нам необязательно создавать на каждую новую задачу новую ветку. Например, у нас есть задача на вёрстку модального окна так же есть задача на отображение модального окна + редактирование модального окна. Все эти задачи можно делать в одной и той же ветке, но обязательно соблюдая правила коммитов.

#### Правила для создания новых веток:

- Создавай новую ветку на каждую новую задачу.
    - Пришёл баглист? Отлично пришло время создавать новую ветку.
    - Начался новый спринт? Ещё лучше, декомпозируем задачи и создаём новые ветки на каждую, но не переусердствуй ведь если можно объединить задачи по разделам - почему бы и нет.
- Наименование ветки. При выборе названия для ветки необходимо отталкиваться от задачи, которую мы будем выполнять.


> **Пример создания ветки**: У нас есть задача исправить футер на странице "редактор правил". Создаём ветку от основной, так как "редактор правил" у нас находится в разделе "согласование цен", то и откалываемся мы от `price_management`, с названием нашей задачи `rules_editor_layout`.

#### Как часто и как правильно коммитить:

    Важно! При внесении правок в пр - вносить их необходимо одним коммитом!

1. Коммитить нужно часто, но не разрывая задачу на куски. Это нужно для того что бы у нас была возможность безболезненно откатить определённые изменения.
2. Так же после каждого коммита нужно отправлять изменения и на удалённый репозиторий.
3. Для коммита нам нужно заглавие - наименование для коммита должно выглядеть следующим образом `<тип>[необязательный контекст]: <описание>`. [Подробнее](https://www.conventionalcommits.org/ru/v1.0.0/).
4. Так же для коммита нужно полное описание выполненной задачи. Например, исправили отображение данных в основной таблице, значит в описание пишем "- Исправил отображение данных в таблице. Теперь при подгрузке данных отображается 17 тип файлов".

>**Пример создания коммитов**: у нас есть список багов для исправления на странице "список процессов", закрыли один баг / закоммитили / перешли к другому / повторили. Наименование коммита состоит из следующих частей:
>> - `<тип>` - Обозначает то, что мы делали. [Все вариации типов](https://github.com/angular/angular/blob/22b96b9/CONTRIBUTING.md#type).
>> - `[необязательный контекст]` - Scope обозначает область изменений, обычно используется только с npm пакетами. [Подробнее](https://github.com/angular/angular/blob/22b96b9/CONTRIBUTING.md#scope).
>> - `<описание>` - Краткое описание сделанного. [Подробнее](https://github.com/angular/angular/blob/22b96b9/CONTRIBUTING.md#subject).

>**Пример генерации наименования коммита**: `fix: исправил отображение данных в таблице`

>*На каком языке описывать оглавление и коментарии?* Всё кроме `<тип>` и `[необязательный контекст]` описываем на русском языке.

#### Удаление веток:

Ветку нужно удалять или отмечать её удаление в том случае, если мы уверены что следующие задачи не будут задействовать её, а так же будучи полностью уверенным, что данную ветку никто не использует.
>Удалять или менять основные ветки нельзя.

## Интегрированная среда разработки:

>IDE - она же интегрированная среда разработки. На проекте можно использовать любую IDE, главное что бы  было удобно работать.

#### Обязательные плагины для IDE:

- [Prettier](https://prettier.io/) - плагин для удобного поддержания общего стиля кода.

**Настройка Prettier**:

1. Скачиваем плагин для используемой IDE. [VSCode](https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode)/[WebStorm](https://plugins.jetbrains.com/plugin/10456-prettier/versions).
2. Далее необходимо установить/изменить Prettier в качестве инструмента для форматирования по умолчанию. В VSCode нужно открыть параметры и в поисковой строке вписать "Default Formatter", далее выбрать Prettier.
3. После проделанных действий необходимо включить автоматическое форматирования кода после его сохранения. В VSCode это можно через всё теже параметры и поисковую строку - вписав туда "Format On Save" и активировав галочку.

>Больше информации можно получить [тут](https://www.digitalocean.com/community/tutorials/how-to-format-code-with-prettier-in-visual-studio-code-ru).

## Реализация:

- **Документ-маршрутизатор** - место, откуда можно добраться до всех артефактов проекта. Это может быть страница в Confluence, пространство Notion или просто Google-документ. Важно создать единую точку входа - пусть там будут только ссылки на разные инструменты и источники, но вам не придется запоминать пути поиска нужного файла.

- **Артефакты проектных процессов** - флоу процесса разработки, статусная модель задач, доски с беклогом, план-график проекта, список нужных контактов и пр. Наличие такой документации налаживает процесс работы и делает его более комфортным. А также сильно разгружает аналитика/менеджера/тимлида и всех, кого волнует выполнение задач и сроки.

- **Глоссарий**: Приводит всех участников работ к одному понятийному полю. Особенно полезен там, где много специальных терминов или разночтений. На некоторых проектах достаточно всего нескольких определений, но полезно все же их зафиксировать.

- **Артефакты бизнес-потребности и бизнес-процесса**: Agile-манифест гласит: “Работающий продукт важнее исчерпывающей документации”. Но нельзя разработать работающий “как надо” продукт без четкого понимания, что же мы все-таки делаем и зачем. Бизнес-требования, схема процесса или просто письмо с постановкой от заказчика - что-то должно быть.

- **Концептуальная модель системы**: Описание основных сущностей, верхнеуровневая функциональность и взаимодействие с другими системами. Используйте IDEF0, "дорожки" BPMN, просто схему или текстовый перечень - главное обозначить принцип работы вашей системы.

- **Классы пользователей и уровни доступа**: Такая памятка очень поможет при разработке требований - ведь всегда надо понимать, для кого и что делается. А путаница и в итоге неверный доступ - потенциально большие проблемы.

- **Cценарии использования**: Даже если вы не используете этот инструмент для разработки требований - какой-то сценарий работы системы у вас есть. Это может быть инструкция для пользователей или тех. поддержки. Или последовательность вызовов с параметрами, если речь идет о взаимодействии систем.

- **Логика работы системы**: По коду или БД не всегда получается понять смысл функционала. Например, формула расчета стоимости скорее всего задается бизнес-правилами, о которых коду ничего не известно. Эти данные так или иначе передаются разработчикам при постановке задачи. Удобно сразу их записывать в виде читаемого документа, а в задачах вставлять только ссылки на место в этом документе. А если в тот же документ прикреплять тест-кейсы - будет совсем красиво.

- **Описание АПИ**: Да пребудет с нами swagger и стандартный формат ответа методов. Если с вами интегрируются внешние компании - не обойтись и без подробного описания параметров.

- **Тестовые данные**: Среды, учетные записи и все, что нужно, чтобы не сводить с ума тестировщика однообразными вопросами.

- **Ограничения/нефункциональные требования**: Вы договорились, что рассчитываете максимум на 100 пользователей? Делаете импорт справочников раз в сутки в час ночи? Внешняя система не умеет принимать какие-то значения? Сделайте приятно себе в будущем - запишите все эти детали. (Обязательно упомянуть про договорённость отправления не более чем 5 одновременных запросов к api).

- Другие типы документов: 

    - **Архитектура системы**: Иногда необходимо детальное описание сервисов и их взаимодействия. Например, если сервисов несколько и они взаимосвязаны, или если архитектура микросервисная.

    - **Требования к данным**: Логическая модель, требования к составу и форму данных, особенности работы с ними и прочее. Всё это не всегда покрывается характеристиками БД - в таком случае полезно зафиксировать их в отдельном документе. Сюда же можно добавить соглашения о формате БД - принципы наименования таблиц и атрибутов, используемые типы данных и т.п.

    - **UX/UI макеты и прототипы**: Их лучше сразу собирать в одном известном всем месте и держать в актуальном состоянии. С чехардой в макетах разбираться потом очень сложно. Просто представьте, что у вас хотя бы 3 экрана и у каждого хотя бы по 5 состояний. И аналитик, дизайнер и разработчики смотрят каждый в свой проект в фигме. (Уже реализованно).

    - **Описание интеграций**: Протоколы интеграций, спецификации АПИ, процессы и потоки данных и всё, что необходимо для избежания недоразумений при взаимодействии с другими системами.

    - **Безопасность**: В целом параметры безопасности могут быть описаны вместе с доступами или нефункциональными требованиями, либо же наследоваться от общего контура ИТ компании. Но бывают системы с приоритетом или особым подходом к этой характеристике.

    - **Внешняя документация**: Документы для пользователей, партнеров, надзорных органов и прочие артефакты, которыми система общается с внешним миром.